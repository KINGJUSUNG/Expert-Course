1. 캡슐화에 대해 기술하세요.
캡슐화란 서로 관련된 데이터와 함수들을 클래스라는 하나의 캡슐 속으로 묶어주는 것을 의미한다.
객체지향 프로그래밍에서는 클래스를 사용해서 관련된 데이터와 함수들을 하나의 캡슐로 묶는다.
그리고 이로서 캡슐 내부와 외부를 구분할 수 있고 이를 통해 클래스 내부의 정보를 은닉할 수 있다.
a : 캡슐화를 하는 이유는 캡슐 내부와 외부를 구분하기 위해서

2. 정보은닉에 대해 기술하세요.
정보은닉은 캡슐 내부의 데이터와 함수들을 외부에서 접근하지 못하도록 숨기는 것을 의미한다.
객체지향 프로그래밍에서는 접근지정자를 통해서 이를 구현한다.
정보은닉은 모듈의 독립성을 높여줌으로서 추상화를 향상시켜준다.
여기서 모듈의 독립성이 높아진다는 것은 은닉된 정보는 캡슐 내부에서만 접근할 수 있으므로 캡슐 외부에서의 불필요한 참조를 막을 수 있다는 의미이다.
모듈의 독립성이 높아진다는 것은 재사용성이 높아진다는 것.

모듈 : C 에서는 목적파일, 자바에서는 바이트파일 하나하나를 모듈이라고 함.

3. 추상화에 대해 기술하세요.
추상화란 복잡한 문제를 다루기 위해서 캡슐에서 불필요한 부분들은 숨기고 중요한 부분만을 표현한 것이다.
객체지향관점에서 봤을 때 중요한 부분은 캡슐화된 클래스 혹은 객체 그 자체이고, 불필요한 부분은 그 안의 세부 구현사항들이다.
이렇게 최소한의 정보만을 드러냄으로서 캡슐 즉 객체끼리 서로 최대한 독립적으로 존재하도록 돕는다.
a : 복잡한 것을 간단하게 표현하는 것. 숨겨진 것이 많을수록 추상화가 높아진다.

4. 다형성에 대해 기술하세요.
다형성이란 프로그래밍 관점에서 봤을 때 하나의 연산자나 함수에 상황에 따라 다르게 의미를 부여하는 것이다.
객체지향에서는 오버로딩과 오버라이딩 두가지의 형태를 가지고 있다.
다형성은 코드의 재사용성을 높여주고 일관된 인터페이스를 제공한다는 장점이 있다. 
예를 들어 어떤 함수의 매개변수 타입을 부모타입으로 해놓으면 어떤 자식객체가 들어오든 하나의 부모타입으로 받을 수 있다.
따라서 어떤 자식 객체가 들어오든 코드를 수정할 필요가 없고 사용자는 어떤 자식 객체가 들어오든 신경쓰지 않아도 된다.
a : 오버로딩, 오버라이딩이 중요
오버라이딩 : 상위클래스의 접근제한자 이상의로 정의해야함
다형성이 무엇인지, 다형성이 객체지향에서 어떻게 나타나는지

5. 다음 코드에 대한 설명을 기술하세요.

	interface Runnable {
		void run();
	}

	class Hors implements Runnable {

	}

인터페이스는 특정 기능을 수행하기 위해 선언된 함수들의 집합이자 소프트웨어 서비스에 대한 명세이다. 즉 인터페이스의 추상메소드들은 서비스의 명세들이라고 볼 수 있다.
따라서 Hors 클래스가 Runnable 인터페이스를 구현했다는 것은 그런한 명세들을 실제로 구현하는 클래스가 되었다는 의미이다.
Runnable 인터페이스는 '달리다'라는 명세를 가진 run() 를 가지고 있기 때문에, 이 인터페이스를 구현하는 Horse 클래스는 run()를 구현함으로서 '달리다'라는 명세를 구현하는 것이다.
a : 인터페이스에 멤버 필드가 없는 이유: 모든 객체를 일반화할 수 는 없음. 갖는 속성이 다르기 때문에. 따라서 인터페이스의 메소들을 통해서라도 조금이라도 기능을 통해서 객체들을 일반화시키려는 시도이다.

6. 추상형(추상클래스 또는 인터페이스)에 맞추어 설계를 해야 하는 이유를 기술하세요.
추상클래스나 인터페이스에 선언되어 있는 추상메소드들은 결국 설계에 필요한 특정 기능들을 수행하기 위해 선언된 메소드들이다.
즉 이 메소드들은 현재 설계해야하는 소프트웨어 서비스에 대한 명세들이다. 
따라서 설계단계에서는 기능들의 실제 구현보다는 명세된 기능들에 맞추어 전체적인 틀을 잡는 것이 중요하므로 추상형에 맞추어 설계를 하는 것이 맞다고 생각한다.
a : 구현클래스에 맞춰서 설계하면 '1대 다'의 의존성이 형성되어버림. 대표타입을 두게 되면 객체간의 의존성을 낮출수있음.

7. 다음 코드에 대한 설명을 기술하세요.

	interface Runnable {
	}

	class Hors implements Runnable {
	}

해당 코드에서 Runnable 인터페이스는 Cloneable 인터페이스와 같은 역할을 한다.
즉 Runnable 인터페이스는 JVM에게 Hors 클래스가 '달릴 수 있는' 클래스라는 것을 알려주는 역할을 한다고 생각한다.
즉 JVM 에게 이 클래스는 복제해도 안전하다고 보장해주는 의미가 있다.

8. 다음 코드가 실행이 불가능한 이유를 설명하고 실행 가능하도록 수정하세요.

	class Person {
                  	
	}

	class Student extends Person {
		public void study() {
			System.out.println("공부합니다.");
		}
	}

	Person p = new Student(); 
	p.study(); // 여기서 컴파일 에러가 발생한다.

자바에서는 메소드를 호출하기위해 컴파일 타임에 컴파일러에게 승인을 받아야하는데, 이때 메소드를 호출한 변수의 타입을 보고 승인여부를 결정한다. 즉 해당 상황에서는 변수 p의 타입을 확인한다. 
p는 Person 타입이므로 컴파일러는 Person 클래스에 study() 가 있는 지 확인하지만 없으므로 컴파일타임에 에러가 발생한다.
따라서 Person 클래스에 study() 메소드를 추상메소드로 정의한다면 컴파일타임에 승인도 되고 런타임에 오버라이딩된 Student 의 study() 가 실행될 것이다.
동적바인딩이란?

추상화란 무엇인가?
왜 추상화를 해야하는가?
어떻게 추상화를 하는가?
이로인해 생기는 장점이 무엇인가?