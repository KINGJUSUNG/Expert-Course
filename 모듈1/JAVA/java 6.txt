- 객체끼리의 연관성

객체는 서로 연관을 가질 수 있다. 객체가 다른 객체를 멤버로 가지면 복합객체이다. 
전체객체와 부품객체가 실제로 생성이 되어야만 복합객체로서 유효하다.

일반연관관계(사용) : use-A : 기사클래스가 무기클래스를 잠시 사용한다(메소드의 인자같은 걸로)
특수연관관계(포함) : has-A : 기사클래스가 무기클래스를 멤버로 갖는다(포함한다)
특수연관관계는 집단화(aggregation), 복합화(composition) 두 가지로 나뉨(전체객체와 부품객체의 생성시기에 따라 분류됨)
집단화 : 전체객체와 부품객체의 생성시점이 다르면(new를 하는 시점이 다르면) 집단화이다
복합화 : 전체객체와 부품객체가 동시에 new가 된다면(전체객체의 생성자에서 부품객체가 new가 되는경우) 복합화이다
상속 : is-A : 부모와 자식

-문제점

use_A :
기사클래스 : 싸우다() : 무기를 주어야함 :칼, 활, 도끼
칼로 싸우게끔 하려면 칼을 인수로 받아야함. 활, 도끼도 마찬가지 : 메소드 오버로딩 발생
이 때, 새로운 무기가 생기면? 메소드 하나 추가해야함. 있던 무기가 삭제되면 메소드도 삭제해야함 
결국 클래스를 수정해서 캡슐화가 깨지는 문제 발생

has A :
기사클래스 : 칼, 활, 도끼를 멤버로 가질때도 무기삭제, 추가 시 동일한 문제 발생

이 문제는 상속으로 해결가능.
무기클래스 : 무기를 상속받은 칼, 활, 도끼클래스를 만든다면?
기사는 무기타입 하나면 가지면 됨. 의존도를 낮춤. 즉 모듈화가 쉬워짐
이 무기타입은 추상클래스도, 인터페이스도 될 수 있다.
즉 추상클래스나 인터페이스의 목적은 단일 인터페이스를 제공하는 것이다.
추상클래스나 인터페이스는 상속을 통해서 자식 클래스들을 그룹화한다. 자식클래스들은 해당 규격을 반드시 지켜야하는 것이다.
디자인 패턴의 원칙이다.

오늘 배운 Duck, flyable uml 분석해서 다시 만들어보고 분석꼭!!!!!
