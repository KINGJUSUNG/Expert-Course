- 패키지
패키지는 물리적인 개념이 아니라 논리적인 개념, 즉 Domain 의 개념이다(Domain = 영역, 범위)
jar 란? 여러 파일을 하나의 파일로 묶어 놓은 것
모든 자바 파일은 import java.lang.* 가 자동으로 되어있음
자동으로 필요한 패키지를 import 시키는 단축키 : ctrl + shift + o

- 객체 지향 관점에서 보기
클래스는 서로 관련있는 속성과 행위를 묶어주는 것이다.  따라서 클래스 내부와 외부가 자연스럽게 구분된다.
클래스로 만들어진 객체 역시 내부와 외부가 구분된다. 이를 '캡슐화' 라고 한다.
캡슐화는 왜 필요한가? 즉 객체의 내부와 외부가 왜 구분돼야 하는가? 추상화의 정도를 높이기 위해서
추상화의 정도가 높아진다는 것은 더 많은 데이터를 숨기고 최소한의 인터페이스만 제공한다는 뜻이다.
그렇다면 왜 추상화가 높아야 하는가? 그래야 모듈의 독립성이 높아진다.
그러면 추상화정도를 어떻게 높일까? 접근제한자로 정보은닉(information hiding)을 한다.

- 상속
상속의 장점
1. 부모클래스의 것을 사용할 수 있음
2. 부모클래스 타입으로 자식을 취급할 수 있음

자바에서 다중상속을 지원하지 않는 이유?
다이아몬드 구조로 상속 될 경우 손자는 부모중 누구의 필드를 상속받은 것인가? 애매해짐
따라서 그냥 인터페이스를 제공함. 인터페이스는 필드가 없으니까 그런 문제가 없음.

자식 클래스의 인스턴스를 생성할 때, 명시되어 있지않아도 부모클래스의 default 생성자를 먼저 호출한다.
즉 super() 가 호출됨. 그런데 아래와 같은 경우에는 두번째 생성자에서 super() 가 호출됨.
public class Student extends Person {
	public Student() {
		this(10);
		System.out.println("Student 클래스의 생성자 호출");
	}

	public Student(int n) {
		// 블록 내의 맨 위에 super(); 숨어있음.
		~
		~
	}
}

부모의 멤버를 참조할 때는 super를 사용해라. 부모클래스에 디폴트 생성자가 없는 경우에는
super 사용하여 부모클래스에 있는 생성자를 자식클래스에서 명시적으로 호출해주어야한다.
super() 와 this() 는 성질이 똑같음. 무조건 맨 앞에 나와야 함. 따라서 둘이 같이는 절대 못 옴. 
메소드에 final 이 붙으면 자식클래스에서 오버라이딩 불가
클래스에 final 이 붙으면 이 클래스는 더 이상 상속불가
상위클래스는 하위클래스를 '일반화'한 것이다.
하위클래스는 상위클래스를 '특수화'한 것이다.
객체지향에서는 '일반화'를 지향한다.

- 상속에서의 오버라이딩 원리
우선, 자바에서 객체를 통한 메소드는 호출되기 전 컴파일 타임에 승인을 받아야한다. 컴파일 타임에 하는
검사이므로 자바컴파일러는 단지 변수의 타입만으로 승인 여부를 결정해야 한다. 즉 변수에 해당하는 클래스에
실제로 해당 메소드가 있는 지를 검사한다. 이 때 없으면 승인을 통과하지 못한다.
그렇다면 런타임에는 어떨까? 이 때는 볼 것도 없이 실제로 힙에 생성된 객체의 메소드가 실행된다. 예를 들어
부모 타입의 변수로 자식 객체를 가리키고 자식 객체의 메소드를 호출한 경우, 이 메소드는 부모클래스에도
정의가 되어 있어야 컴파일 타임에 승인을 받을 수 있다. 그리고 객체 자체는 자식 객체로 생성되었기 때문에
메소드의 실행은 자식 객체의 메소드가 실행된다. 그런데 만약 부모클래스로 자식객체를 참조한 뒤,
부모클래스에만 있는 메소드를 호출하면 어떻게 될까? 이 때는 당연히 부모클래스의 메소드가 호출된다. 
즉 부모타입변수로 자식객체를 가리키는 경우 중, 
자식클래스에만 있는 메소드를 호출한다면 승인받지 못하고 컴파일 에러가 난다.
그러나 부모클래스에만 있는 메소드를 호출하면 자식은 어차피 상속받은 상태이므로 적어도 메모리의 
메소드 영역에서는 자식클래스도 그 메소드를 포함하고 있다고 봐도 무방하다. 
따라서 부모클래스에 있는 메소드가 전혀 문제없이 실행된다.

업캐스팅 : 부모로 자식 객체를 참조하는 것
다운캐스팅 : 자식으로 부모 객체를 참조하는 것
concrete 클래스는 구현 클래스
instanceof 연산자는 해당하는 클래스를 물어보는 것이 아니라 해당하는 객체가 무엇인지를 물어보는 것이다
