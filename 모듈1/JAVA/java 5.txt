- 추상클래스
추상클래스는 구현 클래스들의 공통적인 특성을 뽑아내어 만들어낸 클래스임. 추상클래스는 new를 통해서 객체를 생성할 수 없음.
그러나 아예 객체를 생성할 수 없는 것은 아님. 상속받은 구현클래스들이 super() 를 호출해야 객체 생성이 가능함.

추상클래스의 장점은?
1. 구현 클래스들의 공통된 필드와 메소드의 이름을 통일할 목적(인터페이스의 단일화)
2. 구현 클래스를 작성할 때 시간을 절약(상속의 장점인 코드의 재사용성과 일치함)

new를 못하는데 왜 추상클래스에 생성자를 둘까?
1. 상속을 염두에 두고 있기 때문(자식에서 생성자를 호출)
2. 추상클래스의 멤버필드를 초기화하기위해서

설계는 구현클래스가 아닌 추상클래스를 기준으로 설계해야한다.
인터페이스와 추상클래스의 차이: 멤버필드의 유무의 차이

- 추상메소드 
추상메소드는 구현부가 없는 메소드이다.
추상메소드를 하나라도 가지면 해당 클래스는 추상클래스이어야 한다.
추상클래스를 상속받은 자식클래스는 본인이 추상클래스가 아닌 이상 반드시 부모의 추상메소드를 구현해야한다.

부모레퍼런스로 자식객체를 가리킨 경우, 부모레퍼런스로 자식의 멤버들에 직접적으로는 접근할 수 없다. 
자식은 부모의 것을 사용할 수 있지만 부모는 자식의 개인적인 것에는 직접 접근 할 수 없기 때문이다.
그러나 추상메소드를 활용한다면? 추상메소드를 통해서는 자식의 개인적인 것에 충분히 접근 할 수 있다.(오버라이딩 활용)

- 인터페이스
관심분리를 가능하게 한다. 역시 인스턴스 생성 불가능.
사용자는 객체들의 실체가 무엇인지 알 필요가 없고 관심도 없다. 그냥 인터페이스만 보면 된다. 
왜냐하면 사용자는 인터페이스에 해당하는 기능들에만 관심이 있으니까. 예를 들어 비행기 클래스가 '날수있다' 인터페이스를 선언하면 사용자는 비행기 객체 자체에는 전혀 관심이 없고 오직 '날수있다' 는 기능만 신경쓰면 된다. 
날수있어야 다른 나라에 갈 수 있으니까. 즉 사용자에게는 극히 일부의 필요한 정보만 제공하는 것. 추상화의 정도를 높이기 위함일 수 있음.

인터페이스의 이름은 '가능형(~able)' 으로 함. 
인터페이스는 오직 상수필드(static final)만 올 수 있다. 근데 그냥 int a; 이렇게 선언해도 자동으로 public static final 이 붙음.
추상클래스에서는 메소드에 반드시 abstract 를 붙여야 하는데 인터페이스에서는 그럴 필요는 없음. 왜냐하면 역시 자동으로 pubilc abstract 가 붙음.
메소드는 구현부를 가져서는 안됨. 반드시 선언만 가능. 유일하게 구현부를 가질 수 있는 메소드는 'default' 메소드이다. 이 때, default 는 반드시 명시해야함.

인터페이스 함수의 호출 메커니즘은 클래스 상속과 비슷하다. 승인 과정도 똑같음.

instanceof 의 개념
연산자 오른쪽에 부모타입이 오면 무조건 true
같은 부모를 가지더라도 구현객체가 서로 다르면 false

인터페이스도 상속이 가능함. 즉 extends 키워드가 사용가능함. 그러나 같은 인터페이스끼리만 가능.


- 익명 구현 객체
일회성의 구현 객체를 만들기 위해 사용. 즉 객체를 한번 사용할 건데 이것때문에 따로 클래스를 만드는 것이 귀찮은 경우에 사용한다. 사용방법은

인터페이스 변수 = new 인터페이스() {
	// 인터페이스에 선언된 추상 메소드의 실제 메소드 선언
};

보는 것처럼 인터페이스는 객체 생성이 불가능하다. 즉 해당 인터페이스를 구현하는 익명의 객체를 생성한 뒤 그 객체를 인터페이스 타입으로 가리키는 방식이다.

interface Fightable {
	public abstract void fight();
}

public class AppStart {
	public static void main(String[] args) {
		Fightable fighter = new Fightable() {
			public void fight() {
				System.out.println("열심히 싸웁니다.");
			}
		};
		// 여기서 new 는 Fightable 인터페이스를 구현한 클래스의 객체를 fighter 에 반환했다는 뜻이다.
		// 즉, class (이름없음) implements Fighter {...} 인 클래스의 객체를 만들어서 반환한 것이다. 이게 익명구현 객체이다.
	}
}

---------------------------------------------------------------------------------------------------------------------------------

abstract class Fightable {
	public void fight() {
		System.out.println("fight!!");
	}
}

public class AppStart {
	public static void main(String[] args) {
		Fightable fighter = new Fightable() {
			public void fight() {
				System.out.println("열심히 싸웁니다.");
			}
			
			public void cry() {
				System.out.println("엉엉");
			}
		};
		fighter.fight(); // 가능
		fighter.cry(); // 불가능
		// 그런데 fight() 구현부에 cry() 를 넣는 것은 가능
	}
}